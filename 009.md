Macho Pewter Mantaray

High

# Malicious validator can steal withdraw tokens

### Summary

`withdraw.rs:execute` sends token to sender, proof signature does not include target address, vulnerable to front running.

### Root Cause

https://github.com/sherlock-audit/2024-12-seda-protocol/blob/main/seda-chain-contracts/contract/src/msgs/staking/execute/withdraw.rs#L8
```rust
    fn execute(self, deps: DepsMut, env: Env, info: MessageInfo) -> Result<Response, ContractError> {
        // verify the proof
        let chain_id = CHAIN_ID.load(deps.storage)?;
        let public_key = PublicKey::from_hex_str(&self.public_key)?;
        let seq = inc_get_seq(deps.storage, &public_key)?;
@>        self.verify(public_key.as_ref(), &chain_id, env.contract.address.as_str(), seq)?;

        // TODO: add delay after calling unstake
        let token = TOKEN.load(deps.storage)?;

        // error if amount is greater than pending tokens
        let mut executor = state::STAKERS.get_staker(deps.storage, &public_key)?;
        if self.amount > executor.tokens_pending_withdrawal {
            return Err(ContractError::InsufficientFunds(
                executor.tokens_pending_withdrawal,
                self.amount,
            ));
        }

        // update the executor (remove if balances are zero)
        executor.tokens_pending_withdrawal -= self.amount;
        if executor.tokens_pending_withdrawal.is_zero() && executor.tokens_staked.is_zero() {
            state::STAKERS.remove(deps.storage, public_key)?;
        } else {
            state::STAKERS.update(deps.storage, public_key, &executor)?;
        }

        // send the tokens back to the executor
        let bank_msg = BankMsg::Send {
@>            to_address: info.sender.to_string(),
            amount:     coins(self.amount.u128(), token),
        };

        Ok(Response::new()
            .add_message(bank_msg)
            .add_attribute("action", "withdraw")
            .add_events([
                create_executor_action_event(
                    "withdraw",
                    self.public_key.clone(),
                    info.sender.to_string(),
                    self.amount,
                    seq,
                ),
                create_executor_event(executor, self.public_key),
            ]))
    }
}
```
https://github.com/sedaprotocol/seda-common-rs/blob/main/crates/common/src/msgs/staking/execute/withdraw.rs#L24C6-L24C16
```rust
impl VerifySelf for Execute {
    type Extra = U128;

    fn proof(&self) -> Result<Vec<u8>> {
        Ok(hex::decode(&self.proof)?)
    }

@>    fn msg_hash(&self, chain_id: &str, contract_addr: &str, sequence: Self::Extra) -> Result<Hash> {
        Ok(hash([
            "withdraw".as_bytes(),
            &self.amount.to_be_bytes(),
            chain_id.as_bytes(),
            contract_addr.as_bytes(),
            &sequence.to_be_bytes(),
        ]))
    }
}
```

Proof verification relies on seq number, but does not include the sender/to_address. A malicious validator (optimistically or block proposal) can front run the withdraw request from his own address, and steal the withdraw tokens.

### Internal Pre-conditions

-

### External Pre-conditions

-

### Attack Path

1. Honest user tries to withdraw.
2. Malicious validator front runs same request (with signed proof of victim) only from his address.

### Impact

Funds lost.

### PoC

_No response_

### Mitigation

_No response_