Wobbly Lavender Caterpillar

High

# Attacker can frontrun `increaseFees`

### Summary

If the request fee is too low, forwarders and solvers will prioritize other requests with higher fees. In order to speed up the resolving of the pending request user can call `increaseFees()`. But if pending request is timed out, additional fees can be easilly stolen.

### Root Cause

[Link](https://github.com/sherlock-audit/2024-12-seda-protocol/blob/051b5e88a2f530792913910ebf98c50f431b1e3b/seda-evm-contracts/contracts/core/SedaCoreV1.sol#L107-L115)

The issue is possible due to 2 reasons:

1) `requestId` can be replayed. Although in `RequestHandlerBase.sol`  there is a check to prevent generating the same `requestId` if the id is already exists, the same id can be generated after original id was deleted.
Request id is a hash generated based on user inputs - there is no `msg.sender` or `nonce` params, so the same hash can be generated by another user using the same input params (after previous hash was deleted):
```solidity
bytes32 requestId = SedaDataTypes.deriveRequestId(inputs);

function deriveRequestId(RequestInputs memory inputs) internal pure returns (bytes32) {
        return
            keccak256(
                bytes.concat(
                    keccak256(bytes(SedaDataTypes.VERSION)),
                    inputs.execProgramId,
                    keccak256(inputs.execInputs),
                    bytes8(inputs.execGasLimit),
                    inputs.tallyProgramId,
                    keccak256(inputs.tallyInputs),
                    bytes8(inputs.tallyGasLimit),
                    bytes2(inputs.replicationFactor),
                    keccak256(inputs.consensusFilter),
                    bytes16(inputs.gasPrice),
                    keccak256(inputs.memo)
                )
            );
    }
```
2) Pending request can be deleted by anyone after `timeoutPeriod` has passed. However expired requests are still active and can be executed.

### Internal Pre-conditions

None

### External Pre-conditions

Pending request must not be resolved during `timeoutPeriod`.

### Attack Path

1. Bob created request with small fee amount, thus his request was not solved during `timeoutPeriod` (1 day per tests).
2. Solvers post bigger requests from queue, so Bob decided to increase fees for solvers by adding 0.002 ETH to speed up resolving.
3. Amelie frontruns Bob's call and first calls `withdrawTimedOutRequest()`, so Bob's `requestId` was deleted, and after calls `postRequest()` with the same `input` params and 0 fees. Thus the same `requestId`, but with different `requestor` address and fees, will be created:
```solidity
bytes32 requestId = RequestHandlerBase.postRequest(inputs);

        // Store pending request and request details
        _addRequest(requestId);
        _storageV1().requestDetails[requestId] = RequestDetails({ 
            requestor: msg.sender,
            timestamp: block.timestamp,
            requestFee: requestFee,
            resultFee: resultFee,
            batchFee: batchFee,
            gasLimit: inputs.execGasLimit + inputs.tallyGasLimit
        });
```
4. Bob's call will be executed after this, so he will just fund Amelie's request, because `requestDetails[requestId]` was rewritten.
5. Now Amelie can wait when request will be resolved to receive some refunds, or she can block resolving by reverting when she will receive ETH refunds. It can be done by using custom contract to perform attack. And after `timeoutPeriod` will be passed, Amelie can allow to receive ETH and call `withdrawTimedOutRequest()`;
6. 0.002 ETH will be sent to the requestor - attack contract. Amelie receives full additional amount from Bob.

### Impact

Addinional fees provided by requestor can be stolen after `timeoutPeriod` has passed.

### PoC

None

### Mitigation

Add `msg.sender` or `nonce` param in `requestId` generating to prevent id replays by an attacker.