Trendy Tan Goat

High

# Unsigned Transaction Exported Instead of Signed Transaction, Leading to Validator Registration Failures and Financial Risks

The code’s genesis transaction generation process signs the transaction using a transaction builder but then writes out the original unsigned transaction rather than the updated, signed version. 
  In the [GenTxCmd](https://github.com/sherlock-audit/2024-12-seda-protocol/blob/main/seda-chain/cmd/sedad/gentx/gentx.go#L56-L263) function, the command builds an unsigned genesis transaction (stored in `stdTx`) and then wraps it with a transaction builder (`txBuilder`). The signing is performed via [authclient.SignTx](https://github.com/sherlock-audit/2024-12-seda-protocol/blob/main/seda-chain/cmd/sedad/gentx/gentx.go#L233), which updates the builder with the necessary signatures.

## The Bug:  
  After signing, the code calls [writeSignedGenTx](https://github.com/sherlock-audit/2024-12-seda-protocol/blob/main/seda-chain/cmd/sedad/gentx/gentx.go#L246) using the original `stdTx` variable instead of retrieving the signed transaction from the builder (e.g., via `txBuilder.GetTx()`). As a result, the genesis transaction file written to disk remains unsigned.

The core issue arises from a mix-up between the unsigned transaction and the transaction after it has been signed. Here’s a detailed breakdown:

## Root Cause
The command first constructs an unsigned genesis transaction (`stdTx`) from the provided validator creation message. This unsigned transaction is generated by calling:
     ```go
     if err = txf.PrintUnsignedTx(clientCtx, msg); err != nil {
         return errors.Wrap(err, "failed to print unsigned std tx")
     }
     ```
     and then read with:
     ```go
     stdTx, err := readUnsignedGenTxFile(clientCtx, w)
     ```
A transaction builder is created by wrapping the unsigned transaction:
     ```go
     txBuilder, err := clientCtx.TxConfig.WrapTxBuilder(stdTx)
     ```
The signing process is executed using:
     ```go
     err = authclient.SignTx(txFactory, clientCtx, name, txBuilder, true, true)
     if err != nil {
         return errors.Wrap(err, "failed to sign std tx")
     }
     ```
At this point, the signing routine updates the `txBuilder` with the signature, effectively transforming it into a signed transaction.

_**The Critical Flaw – Not Using the Signed Transaction:**_
   - After signing, the code intends to write the signed transaction to an output file.
   - However, instead of extracting the now-signed transaction from the builder (using something like `txBuilder.GetTx()`), the original unsigned transaction (`stdTx`) is passed into the function responsible for writing the transaction:
     ```go
     if err := writeSignedGenTx(clientCtx, outputDocument, stdTx); err != nil {
         return errors.Wrap(err, "failed to write signed gen tx")
     }
     ```
   - As a result, the output file contains the original, unsigned transaction.


## Impacts
An unsigned genesis transaction means the validator’s self-delegation is not properly authenticated. If the network accepts this unsigned transaction (or fails to recognize it), the intended state changes (like fund locking for self-delegation) may not occur, risking misallocation or loss of funds.  
 
## Mitigation
  The fix is to extract the signed transaction from the transaction builder after signing. For example, replace the call:
  ```go
  if err := writeSignedGenTx(clientCtx, outputDocument, stdTx); err != nil { ... }
  ```
  with something like:
  ```go
  signedTx := txBuilder.GetTx()
  if err := writeSignedGenTx(clientCtx, outputDocument, signedTx); err != nil { ... }
  ```